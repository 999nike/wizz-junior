<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wizz Duo Builder</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --panel2:#0b111a;
      --text:#e8eef6; --muted:rgba(232,238,246,.75);
      --line:#263244; --blue:#1f6feb; --red:#d73a49;
      --radius:14px;
    }
    body{font-family:system-ui,Arial;margin:0;background:var(--bg);color:var(--text)}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    h1{margin:0 0 12px;font-size:18px;font-weight:700}
    .grid{display:grid;grid-template-columns:420px 1fr;gap:12px}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
    .card{border:1px solid var(--line);border-radius:var(--radius);padding:12px;background:var(--panel)}
    label{display:block;font-size:12px;opacity:.9;margin:8px 0 6px}
    textarea,input,select,button{
      width:100%;padding:10px;border-radius:12px;border:1px solid var(--line);
      background:var(--panel);color:var(--text);box-sizing:border-box
    }
    textarea{min-height:110px;resize:vertical}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > *{flex:1}
    button{cursor:pointer;background:var(--blue);border:0;font-weight:700}
    button.secondary{background:transparent;border:1px solid var(--line)}
    button.danger{background:var(--red)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .tiny{opacity:.75;font-size:12px;margin-top:8px}
    .tabs{display:flex;gap:8px;margin-top:8px}
    .tab{padding:8px 10px;border-radius:12px;border:1px solid var(--line);background:transparent;cursor:pointer;font-weight:700}
    .tab.active{background:var(--panel2)}
    .chat-split{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:980px){.chat-split{grid-template-columns:1fr}}
    .chat-title{font-size:12px;opacity:.8;margin-bottom:6px}
    .chatbox{
      border:1px solid var(--line);border-radius:12px;padding:10px;
      min-height:260px;max-height:460px;overflow:auto;background:var(--panel2)
    }
    .bubble{
      padding:9px 10px;border-radius:12px;margin:8px 0;
      white-space:pre-wrap;word-break:break-word;border:1px solid var(--line);
      background:var(--panel)
    }
    .bubble.meta{opacity:.85}
    .typing{opacity:.7;font-size:12px;margin:6px 0}
    .status{font-size:12px;opacity:.85;margin-top:10px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid var(--line);font-size:12px;opacity:.9}
    .divider{height:1px;background:var(--line);margin:10px 0}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Wizz Duo Builder <span class="pill">Web Page Generator + Publisher</span></h1>

    <div class="grid">
      <div class="card">
        <label>Mode</label>
        <select id="mode">
          <option value="web_duo" selected>Build Web Page (WS → WJ → WS)</option>
          <option value="ws">WS only</option>
          <option value="wj">WJ only</option>
        </select>

        <label>Goal</label>
        <textarea id="goal" placeholder="Example: Build a clean landing page to promote Junkz Shooter."></textarea>

        <label>Context (optional)</label>
        <textarea id="context" placeholder="Tone, audience, sections, features, pricing/credit pitch, etc. Short is better."></textarea>

        <div class="divider"></div>

        <label>Repo / Project Label (local only)</label>
        <input id="repoLabel" placeholder="Example: 999nike/junkz-shooter-landing (main)" />
        <div class="tiny">
          Saved to your browser only (localStorage). This does NOT change where publishing goes.
        </div>

        <div class="divider"></div>

        <label>Publish to GitHub Repo (server-side)</label>
        <div class="tiny">
          Uses Vercel env vars: <span class="mono">GITHUB_TOKEN, GITHUB_OWNER, GITHUB_REPO, GITHUB_BRANCH</span>.
          Token never touches the browser.
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="send">Build</button>
          <button id="publish" class="secondary" title="Build + commit files into target repo">Build + Publish</button>
        </div>

        <div class="tiny">
          Tip: Keep goals concrete. Example sections: Hero, Trailer, Screenshots, Features, Roadmap, Contact.
        </div>
      </div>

      <div class="card">
        <div class="row" style="align-items:center">
          <div style="flex:2">
            <strong>Duo Conversation</strong>
            <div class="tiny">Clean output only. Toggle Dev Log if you want internals.</div>
          </div>
          <div style="flex:1;text-align:right">
            <div class="tabs" style="justify-content:flex-end">
              <button id="tabChat" class="tab active" type="button">Chat</button>
              <button id="tabDev" class="tab" type="button">Dev Log</button>
            </div>
          </div>
        </div>

        <!-- ===== JOBS PANEL START ===== -->
<div class="divider"></div>

<div class="row" style="align-items:center">
  <strong>Jobs</strong>
  <div style="text-align:right">
    <button id="newJob" class="secondary" type="button">Run as Job</button>
  </div>
</div>

<div class="tiny">
  Jobs are stored locally. You can reopen, rerun, or inspect outputs without rebuilding from scratch.
</div>

<div id="jobs" class="chatbox" style="margin-top:8px; max-height:220px"></div>
<!-- ===== JOBS PANEL END ===== -->


<!-- ===== REPO TOOLS PANEL START ===== -->
<div class="divider"></div>

<div class="row" style="align-items:center">
  <strong>Repo Tools</strong>
  <div style="text-align:right">
    <button id="repoRefresh" class="secondary" type="button">Load Repo Files</button>
  </div>
</div>

<div class="tiny">
  Reads/writes the single repo configured by server env vars (<span class="mono">GITHUB_OWNER / GITHUB_REPO / GITHUB_BRANCH</span>).
</div>

<label style="margin-top:10px;">File</label>
<div class="row">
  <select id="repoFile"></select>
  <button id="repoOpen" class="secondary" type="button">Open</button>
</div>

<label style="margin-top:10px;">Editor</label>
<textarea id="repoEditor" class="mono" style="min-height:220px" placeholder="Open a file to edit it here..."></textarea>

<label style="margin-top:10px;">AI Edit Instruction</label>
<textarea id="aiInstr" placeholder="Example: Refactor this CSS to improve spacing and make buttons consistent. Keep existing styles."></textarea>

<div class="row" style="margin-top:10px;">
  <button id="aiDraft" class="secondary" type="button">Ask WJ (Draft)</button>
  <button id="aiApply" class="secondary" type="button">Apply Draft</button>
  <button id="aiUndo" class="danger" type="button">Undo</button>
</div>

<div class="tiny" id="aiStatus"></div>

<div class="row" style="margin-top:10px;">
  <button id="repoPublish" class="secondary" type="button">Publish File</button>
  <button id="repoDiscard" class="danger" type="button">Discard Changes</button>
</div>

<div class="tiny" id="repoStatus"></div>
<!-- ===== REPO TOOLS PANEL END ===== -->

        <div id="paneChat" style="margin-top:10px;">
          <div class="chat-split">
            <div>
              <div class="chat-title">WS (Senior)</div>
              <div id="chatWS" class="chatbox"></div>
            </div>
            <div>
              <div class="chat-title">WJ (Junior)</div>
              <div id="chatWJ" class="chatbox"></div>
            </div>
          </div>
          <div class="status" id="status"></div>
        </div>

        <div id="paneDev" style="margin-top:10px;display:none">
          <div class="chat-title">Raw JSON (for debugging)</div>
          <div id="dev" class="chatbox mono"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
  const $ = (id) => document.getElementById(id);
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

// ===========================
  // REPO TOOLS (TREE / READ / EDIT / PUBLISH)
  // ===========================
  const REPO_LS = {
    lastPath: "wizz_repo_lastPath_v1",
    lastDraft: "wizz_repo_lastDraft_v1"
  };

  function repoSetStatus(msg){
    const el = $("repoStatus");
    if (el) el.textContent = msg || "";
  }

  function repoSelectedPath(){
    const sel = $("repoFile");
    return sel ? String(sel.value || "").trim() : "";
  }

  function repoSetSelectOptions(paths){
    const sel = $("repoFile");
    if (!sel) return;

    sel.innerHTML = "";
    const list = Array.isArray(paths) ? paths : [];
    if (!list.length){
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No files (or repo not loaded)";
      sel.appendChild(opt);
      return;
    }

    for (const p of list){
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = p;
      sel.appendChild(opt);
    }

    // Restore last file if present
    const last = localStorage.getItem(REPO_LS.lastPath) || "";
    if (last && list.includes(last)){
      sel.value = last;
    }
  }

  async function repoLoadTree(){
    repoSetStatus("Loading repo tree...");
    const btn = $("repoRefresh");
    if (btn) btn.disabled = true;

    try{
      const res = await fetch("/api/repo-tree");
      const data = await res.json().catch(()=>null);

      if (!res.ok || !data?.ok){
        repoSetSelectOptions([]);
        repoSetStatus("Repo tree error: " + (data?.error || ("HTTP " + res.status)));
        return;
      }

      const paths = (data.files || []).map(f => f.path).filter(Boolean);
      paths.sort((a,b)=>a.localeCompare(b));

      repoSetSelectOptions(paths);
      repoSetStatus("Loaded: " + (data.target || "repo") + " (" + paths.length + " files)");
    } catch(e){
      repoSetSelectOptions([]);
      repoSetStatus("Repo tree error: " + String(e));
    } finally {
      if (btn) btn.disabled = false;
    }
  }

  async function repoOpenFile(path){
    const p = String(path || "").trim();
    if (!p){
      repoSetStatus("Pick a file first.");
      return;
    }

    repoSetStatus("Reading: " + p + " ...");
    const openBtn = $("repoOpen");
    if (openBtn) openBtn.disabled = true;

    try{
      const url = "/api/repo-read?path=" + encodeURIComponent(p);
      const res = await fetch(url);
      const data = await res.json().catch(()=>null);

      if (!res.ok || !data?.ok){
        repoSetStatus("Read error: " + (data?.error || ("HTTP " + res.status)));
        return;
      }

      localStorage.setItem(REPO_LS.lastPath, p);
      localStorage.removeItem(REPO_LS.lastDraft);

      const ed = $("repoEditor");
      if (ed) ed.value = data.content || "";

      repoSetStatus("Opened: " + (data.target || "") + " :: " + p);
    } catch(e){
      repoSetStatus("Read error: " + String(e));
    } finally {
      if (openBtn) openBtn.disabled = false;
    }
  }

  async function repoPublishCurrent(){
    const p = repoSelectedPath();
    const ed = $("repoEditor");
    const content = ed ? String(ed.value || "") : "";

    if (!p){
      repoSetStatus("Pick a file first.");
      return;
    }

    repoSetStatus("Publishing: " + p + " ...");
    const pubBtn = $("repoPublish");
    if (pubBtn) pubBtn.disabled = true;

    try{
      const res = await fetch("/api/publish", {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ files: [{ path: p, content }] })
      });

      const data = await res.json().catch(()=>null);

      if (!res.ok || !data?.ok){
        repoSetStatus("Publish error: " + (data?.error || ("HTTP " + res.status)));
        return;
      }

      localStorage.setItem(REPO_LS.lastPath, p);
      localStorage.removeItem(REPO_LS.lastDraft);

      repoSetStatus("Published to: " + (data.target || "") + " :: " + (data.wrote?.[0] || p));
    } catch(e){
      repoSetStatus("Publish error: " + String(e));
    } finally {
      if (pubBtn) pubBtn.disabled = false;
    }
  }

  function repoDiscardChanges(){
    const p = repoSelectedPath();
    if (!p){
      repoSetStatus("Pick a file first.");
      return;
    }
    // Re-open from source to discard local edits
    repoOpenFile(p);
  }

  // ===========================
  // AI COPILOT (WJ FILE EDITOR)
  // ===========================
  const AI_LS = {
    draft: "wizz_ai_draft_v1",
    before: "wizz_ai_before_v1",
    lastInstr: "wizz_ai_instr_v1"
  };

  function aiSetStatus(msg){
    const el = $("aiStatus");
    if (el) el.textContent = msg || "";
  }

  function aiGetOpenFileState(){
    const path = repoSelectedPath();
    const ed = $("repoEditor");
    const content = ed ? String(ed.value || "") : "";
    return { path, content };
  }

  async function aiAskWJDraft(){
    const { path, content } = aiGetOpenFileState();
    const instrEl = $("aiInstr");
    const instr = instrEl ? String(instrEl.value || "").trim() : "";

    if (!path){
      aiSetStatus("Open a file first.");
      return;
    }
    if (!instr){
      aiSetStatus("Write an instruction first.");
      return;
    }

    // persist last instruction
    localStorage.setItem(AI_LS.lastInstr, instr);

    aiSetStatus("Asking WJ for a draft...");
    const btn = $("aiDraft");
    if (btn) btn.disabled = true;

    try{
      // Store "before" snapshot for undo
      localStorage.setItem(AI_LS.before, JSON.stringify({ path, content, ts: Date.now() }));

      const prompt =
        "You are WJ (Junior), acting as a code editor.\n\n" +
        "TASK: Modify the file content according to the instruction.\n" +
        "- Return ONLY the full updated file content.\n" +
        "- Do NOT wrap in markdown.\n" +
        "- Do NOT add explanations.\n" +
        "- Preserve unrelated code exactly.\n\n" +
        "FILE PATH:\n" + path + "\n\n" +
        "INSTRUCTION:\n" + instr + "\n\n" +
        "CURRENT FILE CONTENT:\n" +
        content;

      const res = await fetch("/api/wj", {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ task: prompt, context: "" })
      });

      const raw = await res.text();
      let data=null; try{ data = JSON.parse(raw); } catch {}

      if (!res.ok){
        aiSetStatus("WJ error (HTTP " + res.status + "): " + (data?.error || raw || "Unknown"));
        return;
      }

      // Try common response shapes
      const draft =
        (typeof data === "string" ? data : null) ||
        data?.content ||
        data?.result ||
        data?.text ||
        data?.message ||
        data?.response ||
        data?.output ||
        null;

      if (!draft || typeof draft !== "string"){
        aiSetStatus("WJ returned no draft content. Check Dev Log.");
        return;
      }

      localStorage.setItem(AI_LS.draft, JSON.stringify({ path, draft, ts: Date.now() }));
      aiSetStatus("Draft ready. Review then click Apply Draft.");
      // Also show in Dev Log
      $("dev").textContent = JSON.stringify({ wj_raw: data }, null, 2);
      setTab("dev");
    } catch(e){
      aiSetStatus("Client error: " + String(e));
    } finally {
      if (btn) btn.disabled = false;
    }
  }

  function aiApplyDraft(){
    const pack = localStorage.getItem(AI_LS.draft);
    if (!pack){
      aiSetStatus("No draft stored. Click Ask WJ (Draft) first.");
      return;
    }

    let obj=null;
    try{ obj = JSON.parse(pack); } catch {}

    if (!obj?.draft){
      aiSetStatus("Draft data is corrupted.");
      return;
    }

    const ed = $("repoEditor");
    if (ed) ed.value = obj.draft;

    aiSetStatus("Draft applied to editor. You can Publish File when ready.");
  }

  function aiUndo(){
    const pack = localStorage.getItem(AI_LS.before);
    if (!pack){
      aiSetStatus("No undo snapshot stored.");
      return;
    }

    let obj=null;
    try{ obj = JSON.parse(pack); } catch {}

    if (!obj?.content){
      aiSetStatus("Undo data is corrupted.");
      return;
    }

    const ed = $("repoEditor");
    if (ed) ed.value = obj.content;

    aiSetStatus("Restored previous content (undo).");
  }

  function repoWireUI(){
    const refresh = $("repoRefresh");
    if (refresh) refresh.addEventListener("click", repoLoadTree);

    const open = $("repoOpen");
    if (open) open.addEventListener("click", ()=>repoOpenFile(repoSelectedPath()));

    const pub = $("repoPublish");
    if (pub) pub.addEventListener("click", repoPublishCurrent);

    const disc = $("repoDiscard");
    if (disc) disc.addEventListener("click", repoDiscardChanges);

    const sel = $("repoFile");
    if (sel){
      sel.addEventListener("change", ()=>{
        const p = repoSelectedPath();
        if (p) localStorage.setItem(REPO_LS.lastPath, p);
      });
    }

    const ed = $("repoEditor");
    if (ed){
      ed.addEventListener("input", ()=>{
        // draft is optional; helps when phone refreshes
        localStorage.setItem(REPO_LS.lastDraft, String(ed.value || ""));
      });

      // restore draft if exists
      const draft = localStorage.getItem(REPO_LS.lastDraft);
      if (draft) ed.value = draft;
    }
  }

// ===========================
  // JOBS SYSTEM (LOCAL)
  // ===========================
  const JOBS_KEY = "wizz_jobs_v1";

  function jobsLoad(){
    try { return JSON.parse(localStorage.getItem(JOBS_KEY) || "[]"); }
    catch { return []; }
  }
  function jobsSave(jobs){
    localStorage.setItem(JOBS_KEY, JSON.stringify(jobs));
  }
  function jobsUpsert(job){
    const jobs = jobsLoad();
    const idx = jobs.findIndex(j => j.id === job.id);
    if (idx >= 0) jobs[idx] = { ...jobs[idx], ...job };
    else jobs.unshift(job);
    jobsSave(jobs);
    jobsRender();
  }
  function jobsGet(id){
    return jobsLoad().find(j => j.id === id) || null;
  }

  function jobsRender(){
    const el = $("jobs");
    if (!el) return;

    const jobs = jobsLoad();
    el.innerHTML = "";

    if (!jobs.length){
      const empty = document.createElement("div");
      empty.className = "tiny";
      empty.textContent = "No jobs yet.";
      el.appendChild(empty);
      return;
    }

    for (const j of jobs){
      const d = document.createElement("div");
      d.className = "bubble meta";

      const title = (j.goal || "").trim().slice(0, 90) || "(no goal)";
      const mode  = j.mode || "web_duo";
      const st    = j.status || "unknown";

      const files = Array.isArray(j.files_built) ? j.files_built : [];
      const filesLine = files.length ? `Files: ${files.join(", ")}` : "";

      d.innerHTML = `
        <div><strong>${escapeHtml(title)}</strong></div>
        <div class="tiny">Mode: <span class="mono">${escapeHtml(mode)}</span> • Status: <span class="mono">${escapeHtml(st)}</span></div>
        ${filesLine ? `<div class="tiny">${escapeHtml(filesLine)}</div>` : ""}
        <div class="row" style="margin-top:8px;">
          <button type="button" class="secondary" data-job-open="${escapeHtml(j.id)}">Open</button>
          <button type="button" class="secondary" data-job-rerun="${escapeHtml(j.id)}">Rerun</button>
        </div>
      `;
      el.appendChild(d);
    }

    el.querySelectorAll("[data-job-open]").forEach(btn=>{
      btn.addEventListener("click", () => jobsOpen(btn.getAttribute("data-job-open")));
    });
    el.querySelectorAll("[data-job-rerun]").forEach(btn=>{
      btn.addEventListener("click", () => jobsRerun(btn.getAttribute("data-job-rerun")));
    });
  }

  function jobsOpen(id){
    const j = jobsGet(id);
    if (!j) return;

    $("goal").value = j.goal || "";
    $("context").value = j.context || "";
    $("mode").value = j.mode || "web_duo";

    clearUI();

    if (j.output){
      $("dev").textContent = JSON.stringify(j.output, null, 2);
      setTab("dev");
      setStatus(`Loaded job ${id}`);
    } else {
      setTab("chat");
      setStatus(`Loaded job ${id} (no output yet)`);
    }
  }

  async function jobsRerun(id){
    const j = jobsGet(id);
    if (!j) return;

    $("goal").value = j.goal || "";
    $("context").value = j.context || "";
    $("mode").value = j.mode || "web_duo";

    await run({ publish:false, jobId:id });
  }

  function escapeHtml(str){
    return String(str || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ---------------------------
  // Local-only UI preferences
  // ---------------------------
  const LS_KEYS = {
    repoLabel: "wizzduo_repoLabel_v1"
  };

  function loadLocalPrefs(){
    const el = $("repoLabel");
    if (!el) return;

    const saved = localStorage.getItem(LS_KEYS.repoLabel);
    if (saved) el.value = saved;

    // Save on change (lightweight + reliable)
    el.addEventListener("input", () => {
      localStorage.setItem(LS_KEYS.repoLabel, el.value.trim());
    });
  }

  function setStatus(txt){ const el=$("status"); if(el) el.textContent = txt || ""; }
  function clearUI(){
    $("chatWS").innerHTML = "";
    $("chatWJ").innerHTML = "";
    $("dev").textContent = "";
    setStatus("");
  }
  function addBubble(el, text, cls=""){
    const d=document.createElement("div");
    d.className="bubble"+(cls?" "+cls:"");
    d.textContent=text;
    el.appendChild(d);
    el.scrollTop = el.scrollHeight;
  }
  async function typeLine(el, label){
    const t=document.createElement("div");
    t.className="typing";
    t.textContent=label;
    el.appendChild(t);
    el.scrollTop = el.scrollHeight;
    await sleep(350);
    t.remove();
  }
  function setTab(which){
    const chatBtn=$("tabChat"), devBtn=$("tabDev");
    const chatPane=$("paneChat"), devPane=$("paneDev");
    const chatOn = which === "chat";
    chatBtn.classList.toggle("active", chatOn);
    devBtn.classList.toggle("active", !chatOn);
    chatPane.style.display = chatOn ? "" : "none";
    devPane.style.display  = chatOn ? "none" : "";
  }
  $("tabChat").addEventListener("click", ()=>setTab("chat"));
  $("tabDev").addEventListener("click", ()=>setTab("dev"));

  async function run({ publish=false, jobId=null }){
    const mode = $("mode").value;
    const goal = $("goal").value.trim();
    const context = $("context").value.trim();
    if (!goal) return;

    $("send").disabled = true;
    $("publish").disabled = true;
    clearUI();
    setStatus(publish ? "Building + publishing..." : "Building...");

    // Job tracking
    const activeJobId = jobId || ("job_" + Date.now());
    jobsUpsert({
      id: activeJobId,
      goal,
      context,
      mode,
      status: "running",
      started: Date.now()
    });

    try {
      let url = "/api/duo";
      let payload = { goal, context, mode, publish };

      if (mode === "ws") { url = "/api/ws"; payload = { goal, context }; }
      if (mode === "wj") { url = "/api/wj"; payload = { task: goal, context }; }

      const res = await fetch(url, {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify(payload)
      });

      const raw = await res.text();
      let data=null; try{ data=JSON.parse(raw); }catch{}

      if(!res.ok){
        addBubble($("chatWS"), "ERROR:\n" + (data?.error || raw || "Unknown error"), "meta");
        $("dev").textContent = raw || "";
        setStatus("Error.");

        jobsUpsert({
          id: activeJobId,
          status: "error",
          finished: Date.now(),
          error: data?.error || raw || "Unknown error",
          output_raw: raw || ""
        });

        return;
      }
      if(!data){
        addBubble($("chatWS"), "ERROR:\nServer returned non-JSON:\n" + raw, "meta");
        $("dev").textContent = raw || "";
        setStatus("Error.");

        jobsUpsert({
          id: activeJobId,
          status: "error",
          finished: Date.now(),
          error: "Server returned non-JSON",
          output_raw: raw || ""
        });

        return;
      }

      // Dev log always available
      $("dev").textContent = JSON.stringify(data, null, 2);

      // Update job with partial output
      jobsUpsert({
        id: activeJobId,
        status: "received",
        output: data,
        files_built: Array.isArray(data.files_built) ? data.files_built : (Array.isArray(data.files) ? data.files.map(f=>f.path) : null)
      });

      // Duo web build flow
      if(mode === "web_duo"){
        const wsEl=$("chatWS"), wjEl=$("chatWJ");

        await typeLine(wsEl, "WS is planning...");
        if (data.ws_plan_summary) addBubble(wsEl, data.ws_plan_summary, "meta");

        await typeLine(wjEl, "WJ is building files...");
        if (Array.isArray(data.files_built)){
          addBubble(wjEl, "FILES BUILT:\n" + data.files_built.map(f=>"- "+f).join("\n"), "meta");
        }

        await typeLine(wsEl, "WS is reviewing...");
        if (data.final_summary) addBubble(wsEl, data.final_summary);

        if (data.publish_status){
          addBubble(wsEl, "PUBLISH:\n" + data.publish_status, "meta");
        }

        setStatus("Done.");

        jobsUpsert({
          id: activeJobId,
          status: "done",
          finished: Date.now(),
          output: data,
          files_built: Array.isArray(data.files_built) ? data.files_built : null
        });

        return;
      }

      // WS-only / WJ-only fallback rendering
      addBubble($("chatWS"), JSON.stringify(data, null, 2), "meta");
      setStatus("Done.");

      jobsUpsert({
        id: activeJobId,
        status: "done",
        finished: Date.now(),
        output: data,
        files_built: Array.isArray(data.files_built) ? data.files_built : (Array.isArray(data.files) ? data.files.map(f=>f.path) : null)
      });
    } catch(e){
      addBubble($("chatWS"), "CLIENT ERROR:\n" + String(e), "meta");
      setStatus("Error.");

      try {
        const activeJobId = jobId || null;
        if (activeJobId){
          jobsUpsert({
            id: activeJobId,
            status: "error",
            finished: Date.now(),
            error: String(e)
          });
        }
      } catch {}
    } finally {
      $("send").disabled = false;
      $("publish").disabled = false;
    }
  }

  $("send").addEventListener("click", ()=>run({ publish:false }));
  $("publish").addEventListener("click", ()=>run({ publish:true }));

  // Run as Job creates a new job id and runs without publishing
  const newJobBtn = $("newJob");
  if (newJobBtn){
    newJobBtn.addEventListener("click", ()=>run({ publish:false, jobId: "job_" + Date.now() }));
  }

  loadLocalPrefs();
  repoWireUI();
  // Optional: auto-load tree on first visit
  // repoLoadTree();
  jobsRender();
  </script>

  <!-- ERUDA: working, always-available launcher (no <button> styling conflicts) -->
  <script>
  (function(){
    const ERUDA_KEY_OPEN = "wizz_eruda_open_v1";   // "1" or "0"
    const ERUDA_KEY_POS  = "wizz_eruda_pos_v1";    // "br"|"bl"|"tr"|"tl"

    function makeLauncher(){
      const el = document.createElement("div");
      el.textContent = "⚙ Debug";
      el.setAttribute("role", "button");
      el.style.cssText = [
        "position:fixed",
        "z-index:999999",
        "padding:10px 12px",
        "border-radius:999px",
        "border:1px solid rgba(255,255,255,.25)",
        "background:rgba(15,22,32,.92)",
        "color:#fff",
        "font:12px system-ui,Arial",
        "font-weight:700",
        "cursor:pointer",
        "user-select:none",
        "opacity:.92"
      ].join(";");
      document.body.appendChild(el);
      return el;
    }

    function applyPos(el, pos){
      // clear anchors
      el.style.left = "";
      el.style.right = "";
      el.style.top = "";
      el.style.bottom = "";

      // default bottom-right
      if (!pos) pos = "br";
      if (pos === "br") { el.style.right="12px"; el.style.bottom="12px"; }
      if (pos === "bl") { el.style.left="12px"; el.style.bottom="12px"; }
      if (pos === "tr") { el.style.right="12px"; el.style.top="12px"; }
      if (pos === "tl") { el.style.left="12px"; el.style.top="12px"; }
    }

    function loadScript(src){
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    async function ensureEruda(){
      if (window.eruda && typeof eruda.init === "function") return true;

      // Try unpkg, then jsdelivr
      try {
        await loadScript("https://unpkg.com/eruda/eruda.min.js");
      } catch {
        try {
          await loadScript("https://cdn.jsdelivr.net/npm/eruda/eruda.min.js");
        } catch {
          return false;
        }
      }
      return (window.eruda && typeof eruda.init === "function");
    }

    function setOpen(isOpen, launcher){
      localStorage.setItem(ERUDA_KEY_OPEN, isOpen ? "1" : "0");
      launcher.textContent = isOpen ? "⚙ Debug (ON)" : "⚙ Debug";
      try {
        if (!window.eruda) return;
        if (!eruda._isInited) eruda.init();
        if (isOpen) eruda.show(); else eruda.hide();
      } catch {}
    }

    const launcher = makeLauncher();
    const savedPos = localStorage.getItem(ERUDA_KEY_POS) || "br";
    applyPos(launcher, savedPos);

    // tap toggles open/close
    launcher.addEventListener("click", async () => {
      const ok = await ensureEruda();
      if (!ok) {
        launcher.textContent = "⚙ Debug (BLOCKED)";
        alert("Eruda could not load (CDN blocked/unreachable).");
        return;
      }
      const isOn = localStorage.getItem(ERUDA_KEY_OPEN) === "1";
      setOpen(!isOn, launcher);
    });

    // long press cycles corner position
    let pressTimer = null;
    launcher.addEventListener("touchstart", () => {
      pressTimer = setTimeout(() => {
        const order = ["br","bl","tr","tl"];
        const cur = localStorage.getItem(ERUDA_KEY_POS) || "br";
        const idx = order.indexOf(cur);
        const next = order[(idx + 1) % order.length];
        localStorage.setItem(ERUDA_KEY_POS, next);
        applyPos(launcher, next);
      }, 450);
    }, { passive:true });

    launcher.addEventListener("touchend", () => {
      if (pressTimer) clearTimeout(pressTimer);
      pressTimer = null;
    });

    // restore open state on load (optional)
    (async () => {
      const wantsOpen = localStorage.getItem(ERUDA_KEY_OPEN) === "1";
      if (!wantsOpen) return;
      const ok = await ensureEruda();
      if (!ok) return;
      setOpen(true, launcher);
    })();
  })();
  </script>

</body>
</html>
